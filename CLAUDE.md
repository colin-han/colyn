# Claude 工作指南

本文档包含 Claude 在本项目中应遵循的工作流程和规范。

---

## 安装相关

### 更新 Claude Code
- 如果需要更新 Claude Code 时，使用 `volta install` 代替 `npm install -g` 命令

---

## 通用规范

### 语言
* 总是用中文和我交互

### 包管理
* node 包管理使用 `volta run yarn` 命令

### 日志记录
* 总是把你对当前过程的总结 markdown 文件保存在项目根目录下的 `.claude/logs` 目录下

### 代码清理
* 任务告一段落后，检查代码库中的所有修改，清理中间调试过程添加的代码，仅保留必要的日志代码

---

## 问题调查流程

当我让你调查代码问题时，永远遵守以下流程：

1. **重现问题** - 先尝试复现问题
2. **分析日志** - 查看相关日志输出
3. **查找根因** - 定位问题的根本原因
4. **解决问题** - 实施修复
5. **验证问题** - 确认问题已解决

⚠️ **重要**：在重现问题之前不要猜测问题的根源，必须通过重现问题来确定问题的根源。

---

## TypeScript 规范

* 不要使用 `any` 类型
* 禁止使用 `--no-verify` 提交代码

---

## 命令输出规范（双层架构）

本项目使用 Bash + Node.js 双层架构，**必须严格区分 stdout 和 stderr**：

### 输出流规则

| 输出流 | 用途 | 使用场景 |
|--------|------|----------|
| **stderr** | 给用户看的信息 | 进度提示、成功/错误信息、表格输出、交互提示 |
| **stdout** | 给 bash 脚本解析的 JSON | 命令执行结果（`outputResult()`） |

### 实现要求

1. **所有用户提示信息必须输出到 stderr**
   - 使用 `src/utils/logger.ts` 中的函数：`output()`, `outputSuccess()`, `outputError()` 等
   - 这些函数已封装为输出到 stderr

2. **交互式 prompt 必须配置 `stdout: process.stderr`**
   ```typescript
   // ✅ 正确
   await enquirer.prompt({
     type: 'confirm',
     message: '确认操作？',
     stdout: process.stderr  // 必须添加这一行
   });

   // ❌ 错误 - 会输出到 stdout，用户看不见
   await enquirer.prompt({
     type: 'confirm',
     message: '确认操作？'
   });
   ```

3. **Spinner 加载动画必须配置 `stream: process.stderr`**
   ```typescript
   // ✅ 正确
   const spinner = ora({
     text: '处理中...',
     stream: process.stderr  // 必须添加这一行
   }).start();

   // ❌ 错误 - 会输出到 stdout，用户看不见
   const spinner = ora('处理中...').start();
   ```

4. **只有 JSON 结果输出到 stdout**
   - 使用 `outputResult()` 函数
   - 供 shell/colyn.sh 脚本解析

### 原因

shell/colyn.sh 会捕获 stdout 用于解析 JSON：
```bash
result=$("$COLYN_BIN" "$@")  # 捕获 stdout
```
如果提示信息输出到 stdout，用户将看不到这些信息。

---

## 需求变更工作流程 🔄

### 1. 收到修改需求时

#### 第一步：检查现有文档 📋
在开始实现之前，必须先检查：

- [ ] 设计文档（`docs/design-*.md`）
- [ ] 需求文档（`docs/requirement-*.md`）
- [ ] 已有的实现代码
- [ ] 相关的日志记录（`.claude/logs/*.md`）

#### 第二步：对比分析 🔍
分析新需求与现有设计的关系：

- [ ] 新需求是否与现有设计冲突？
- [ ] 是否修改了已明确的设计决策？
- [ ] 是否影响其他相关功能？
- [ ] 是否需要修改多个文档？

#### 第三步：提醒用户（如有冲突）⚠️

如果检测到冲突，**必须先提醒用户**，格式如下：

```
⚠️ 检测到需求冲突

现有文档：docs/xxx.md 第 X 节
当前设计：[描述现有设计]

您的新需求：[描述新需求]

冲突点：
1. [列出具体冲突]
2. [列出影响范围]

可选方案：
A. [保持现有设计]
B. [修改为新需求]
C. [折中方案]

请确认如何处理？
```

#### 第四步：等待用户确认 ⏸️

**⚠️ 重要**：
- ❌ 不要直接开始实现
- ✅ 让用户明确选择方案
- ✅ 获得确认后再继续

---

### 2. 实现完成后

#### 必须更新的文档清单 📝

每次实现完成后，必须检查并更新以下文档：

- [ ] **设计文档** (`docs/design-*.md`)
  - 修改了哪些设计决策？
  - 新增了哪些功能？
  - 改变了哪些行为？

- [ ] **需求文档** (`docs/requirement-*.md`)
  - 是否需要更新需求说明？
  - 是否需要添加新的用例？

- [ ] **实现日志** (`.claude/logs/*.md`)
  - 创建新的日志文件记录本次修改
  - 包含背景、实现细节、测试结果

- [ ] **README.md**（如果影响用户使用）
  - 是否改变了使用方式？
  - 是否新增了功能？

- [ ] **示例代码**
  - 文档中的代码示例是否需要更新？
  - 是否与实际实现一致？

#### 提供更新清单 ✅

实现完成后，必须明确告知用户：

```
## 文档更新清单

✅ 已更新：
- docs/design-xxx.md - 第 X 节：[更新内容]
- .claude/logs/xxx-20260115.md - 完整实现记录

📝 建议检查：
- docs/README.md - 可能需要更新使用说明

⚠️ 相关影响：
- 命令 Y 可能受到影响，建议检查
```

---

### 3. 文档一致性检查 🔍

在完成实现和文档更新后，进行最终检查：

- [ ] 设计文档中的代码示例与实际实现一致
- [ ] 需求文档中的描述与实现功能一致
- [ ] 所有相关文档都已更新
- [ ] 没有留下过时或冲突的信息

---

## 示例场景

### ❌ 错误的处理方式

用户："add命令执行后应该自动进入worktree目录"

Claude：直接开始解释技术限制和提供方案...

**问题**：
1. 没有检查设计文档
2. 不知道是否已有相关设计
3. 可能推翻之前的决策

---

### ✅ 正确的处理方式

用户："add命令执行后应该自动进入worktree目录"

Claude：
```
让我先检查一下现有的设计文档...

⚠️ 检测到设计变更

现有设计（docs/design-add-command.md 第 8 节）：
✓ 成功后显示 `cd worktreePath` 命令
✓ 用户手动复制执行

您的新需求：
✓ add 命令执行后自动进入 worktree 目录

设计变更分析：
1. 技术限制：Node.js 子进程无法修改父 shell 的工作目录
2. 现有设计是有意为之（输出命令供用户执行）
3. 需要额外的 shell 函数封装才能实现自动切换

可选方案：
A. 保持现有设计（输出 cd 命令）
B. 添加 shell 函数封装方案到文档
C. 添加 --print-path 选项配合 shell 函数
D. 改进输出格式，让 cd 命令更易复制

请选择方案？
```

[等待用户确认后再继续实现]

---

## 承诺 🤝

遵循此工作流程可以确保：

- ✅ 文档和代码始终保持一致
- ✅ 设计决策有迹可循
- ✅ 避免无意中推翻之前的设计
- ✅ 给用户充分的决策权
- ✅ 项目维护更加清晰可靠

**每次收到需求变更时，我都会严格执行这个流程。**
