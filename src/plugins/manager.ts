/**
 * PluginManager — 工具链插件管理器
 *
 * 负责：
 * - 维护已注册插件列表
 * - 根据激活插件名称列表分发各扩展点调用
 * - 统一处理 PluginCommandError（verbose 模式下展示命令输出）
 */

import { type ToolchainPlugin, type PortConfig, type RepairSettingsContext, PluginCommandError } from '../types/plugin.js';
import { outputError } from '../utils/logger.js';
import { addToGitignore } from './utils.js';

export class PluginManager {
  private readonly plugins: Map<string, ToolchainPlugin> = new Map();

  /**
   * 注册插件
   */
  register(plugin: ToolchainPlugin): void {
    this.plugins.set(plugin.name, plugin);
  }

  /**
   * 获取所有已注册的插件列表
   */
  getAllPlugins(): ToolchainPlugin[] {
    return Array.from(this.plugins.values());
  }

  /**
   * 获取激活的插件列表
   * @param activePluginNames 激活插件名称数组（工具链类型标识符列表）
   */
  private getActivePlugins(activePluginNames: string[]): ToolchainPlugin[] {
    return activePluginNames
      .map((name) => this.plugins.get(name))
      .filter((p): p is ToolchainPlugin => p !== undefined);
  }

  /**
   * 自动检测并返回匹配的插件名称列表
   * @param worktreePath 检测目录
   */
  async detectPlugins(worktreePath: string): Promise<string[]> {
    const matched: string[] = [];
    for (const plugin of this.plugins.values()) {
      if (await plugin.detect(worktreePath)) {
        matched.push(plugin.name);
      }
    }
    return matched;
  }

  // ════════════════════════════════════════════
  // 环境配置扩展点
  // ════════════════════════════════════════════

  /**
   * 返回第一个非 null 的端口配置
   */
  getPortConfig(activePluginNames: string[]): PortConfig | null {
    for (const plugin of this.getActivePlugins(activePluginNames)) {
      const config = plugin.portConfig?.();
      if (config !== undefined && config !== null) {
        return config;
      }
    }
    return null;
  }

  /**
   * 读取运行时配置 — 返回第一个非 null 的结果
   */
  async readRuntimeConfig(
    worktreePath: string,
    activePluginNames: string[]
  ): Promise<Record<string, string> | null> {
    for (const plugin of this.getActivePlugins(activePluginNames)) {
      if (!plugin.readRuntimeConfig) continue;
      const config = await plugin.readRuntimeConfig(worktreePath);
      if (config !== null) return config;
    }
    return null;
  }

  /**
   * 写入运行时配置 — 调用所有激活插件的 writeRuntimeConfig
   */
  async writeRuntimeConfig(
    worktreePath: string,
    config: Record<string, string>,
    activePluginNames: string[]
  ): Promise<void> {
    for (const plugin of this.getActivePlugins(activePluginNames)) {
      if (plugin.writeRuntimeConfig) {
        await plugin.writeRuntimeConfig(worktreePath, config);
      }
    }
  }

  /**
   * 获取 dev server 命令 — 返回第一个非 null 的结果
   */
  async getDevServerCommand(
    worktreePath: string,
    activePluginNames: string[]
  ): Promise<string[] | null> {
    for (const plugin of this.getActivePlugins(activePluginNames)) {
      if (!plugin.devServerCommand) continue;
      const cmd = await plugin.devServerCommand(worktreePath);
      if (cmd !== null) return cmd;
    }
    return null;
  }

  // ════════════════════════════════════════════
  // 生命周期操作
  // ════════════════════════════════════════════

  /**
   * 确保激活插件的运行时配置文件被 .gitignore 忽略
   */
  async ensureRuntimeConfigIgnored(
    worktreePath: string,
    activePluginNames: string[]
  ): Promise<void> {
    for (const plugin of this.getActivePlugins(activePluginNames)) {
      if (!plugin.getRuntimeConfigFileName) continue;
      const filename = plugin.getRuntimeConfigFileName();
      if (!filename) continue;
      await addToGitignore(
        worktreePath,
        filename,
        [filename],
        'Runtime config (auto-generated by colyn)'
      );
    }
  }

  /**
   * 运行指定工具链插件的 repairSettings，返回更新后的配置
   *
   * 插件通过 repairSettings 检查项目配置，自动发现或交互询问必要的配置项。
   * 调用方负责将结果保存到 settings 文件（通过 saveRepairSettingsResult）。
   *
   * @param worktreePath 子项目目录路径
   * @param toolchainName 工具链名称（插件标识符）
   * @param currentSettings 当前已保存的工具链专属配置
   * @param nonInteractive 是否非交互模式（默认 false）
   * @returns 更新后的配置，若插件未实现 repairSettings 则返回 null
   */
  async runRepairSettings(
    worktreePath: string,
    toolchainName: string,
    currentSettings: Record<string, unknown>,
    nonInteractive = false
  ): Promise<Record<string, unknown> | null> {
    const plugin = this.plugins.get(toolchainName);
    if (!plugin || !plugin.repairSettings) return null;

    const context: RepairSettingsContext = {
      projectRoot: '',
      worktreePath,
      currentSettings,
      nonInteractive,
    };

    return await plugin.repairSettings(context);
  }

  /**
   * 运行所有激活插件的 install
   */
  async runInstall(
    worktreePath: string,
    activePluginNames: string[],
    verbose?: boolean
  ): Promise<void> {
    for (const plugin of this.getActivePlugins(activePluginNames)) {
      if (!plugin.install) continue;
      try {
        await plugin.install(worktreePath);
      } catch (error) {
        if (error instanceof PluginCommandError) {
          if (verbose) {
            outputError(error.output);
          }
          throw error;
        }
        throw error;
      }
    }
  }

  /**
   * 运行所有激活插件的 lint
   */
  async runLint(
    worktreePath: string,
    activePluginNames: string[],
    verbose?: boolean
  ): Promise<void> {
    for (const plugin of this.getActivePlugins(activePluginNames)) {
      if (!plugin.lint) continue;
      try {
        await plugin.lint(worktreePath);
      } catch (error) {
        if (error instanceof PluginCommandError) {
          if (verbose) {
            outputError(error.output);
          }
          throw error;
        }
        throw error;
      }
    }
  }

  /**
   * 运行所有激活插件的 build
   */
  async runBuild(
    worktreePath: string,
    activePluginNames: string[],
    verbose?: boolean
  ): Promise<void> {
    for (const plugin of this.getActivePlugins(activePluginNames)) {
      if (!plugin.build) continue;
      try {
        await plugin.build(worktreePath);
      } catch (error) {
        if (error instanceof PluginCommandError) {
          if (verbose) {
            outputError(error.output);
          }
          throw error;
        }
        throw error;
      }
    }
  }

  /**
   * 运行所有激活插件的 publish
   */
  async runPublish(
    worktreePath: string,
    activePluginNames: string[],
    verbose?: boolean
  ): Promise<void> {
    for (const plugin of this.getActivePlugins(activePluginNames)) {
      if (!plugin.publish) continue;
      try {
        await plugin.publish(worktreePath);
      } catch (error) {
        if (error instanceof PluginCommandError) {
          if (verbose) {
            outputError(error.output);
          }
          throw error;
        }
        throw error;
      }
    }
  }

  /**
   * 检查激活插件是否满足发布条件
   */
  async runCheckPublishable(
    worktreePath: string,
    activePluginNames: string[]
  ): Promise<boolean> {
    const activePlugins = this.getActivePlugins(activePluginNames);
    for (const plugin of activePlugins) {
      // 插件未实现 publish，则视为不可发布
      if (!plugin.publish) {
        return false;
      }

      if (!plugin.checkPublishable) {
        continue;
      }

      const publishable = await plugin.checkPublishable(worktreePath);
      if (!publishable) {
        return false;
      }
    }

    return true;
  }

  /**
   * 读取当前版本号 — 返回第一个非 null 的结果
   */
  async runReadVersion(
    worktreePath: string,
    activePluginNames: string[]
  ): Promise<string | null> {
    for (const plugin of this.getActivePlugins(activePluginNames)) {
      if (!plugin.readVersion) continue;
      const version = await plugin.readVersion(worktreePath);
      if (version !== null) return version;
    }
    return null;
  }

  /**
   * 运行所有激活插件的 bumpVersion
   * 若已激活插件未实现此方法，则报错终止
   */
  async runBumpVersion(
    worktreePath: string,
    version: string,
    activePluginNames: string[]
  ): Promise<void> {
    const activePlugins = this.getActivePlugins(activePluginNames);
    for (const plugin of activePlugins) {
      if (!plugin.bumpVersion) {
        throw new Error(
          `Plugin "${plugin.name}" does not implement bumpVersion. Cannot proceed with release.`
        );
      }
      await plugin.bumpVersion(worktreePath, version);
    }
  }
}
